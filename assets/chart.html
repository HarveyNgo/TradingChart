<html>
      <head>
        <meta charset="utf-8" />
        <script type="text/javascript" src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
        <style>
          html, body, #container {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: 'red';
          }
        </style>
      </head>
      <body>
        <div id="container"></div>
        <script>

        // Create the Lightweight Chart within the container element
        const chart = LightweightCharts.createChart(
            document.getElementById('container'),{
                width: window.innerWidth,
                height: window.innerHeight ,
                layout: { 
                    background: { color: "#fff" },
                    textColor: "#000"
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: true,
                },
                grid: {
                  vertLines: { color: '#eee' },
                  horzLines: { color: '#eee' },
                },
            }
        );
      
   
        function generateMockCandlestickData(count, days) {
          const result = [];
          let currentTime = Math.floor(Date.now() / 1000); // current time in seconds
          let lastClose = 100; // starting price

          for (let i = 0; i < days; i++) {
            const open = lastClose;
            const high = open + Math.random() * 5;
            const low = open - Math.random() * 5;
            const close = low + Math.random() * (high - low);
            const value = (high+low)/2

            result.push({
              time: currentTime,
              open: parseFloat(open.toFixed(2)),
              high: parseFloat(high.toFixed(2)),
              low: parseFloat(low.toFixed(2)),
              close: parseFloat(close.toFixed(2)),
              value: parseFloat(value.toFixed(2)),
              date: new Date(currentTime * 1000).toISOString().slice(0, 10), // yyyy-mm-dd
            });

            currentTime -= (60*60*24); // go back in time
            lastClose = close;
          }
          console.log('hung generateMockCandlestickData:', result);
          return result.reverse(); // oldest first
        }


        const data = generateMockCandlestickData(10,30);

        function formatForHistogramData(data) {
            return data.map(item => ({
                ...item,
                value: Math.abs(item.close - item.open),
                color: item.close > item.open ? 'green':'red',
            }));
        }

        function formatForMinMaxLineData(data) {
          const values = data.map(item => item.value);
          // Get object with min value
          const minValueObject = data.reduce((minObj, item) => 
            item.value < minObj.value ? item : minObj
          );

          // Get object with max value
          const maxValueObject = data.reduce((maxObj, item) => 
            item.value > maxObj.value ? item : maxObj
          );
          const newData =  [{
            ...minValueObject,
            time:data[0].time
          }, {...maxValueObject,
            time:data[data.length-1].time
          }]
          console.log('hung formatForMinMaxLineData:', newData);
            return newData;
          }

          const candleStickSeries = chart.addSeries(LightweightCharts.CandlestickSeries);
          candleStickSeries.applyOptions({
              wickUpColor: 'green',
              upColor: 'green',
              wickDownColor: 'red',
              downColor: 'red',
              // borderVisible: false,
          });
          candleStickSeries.priceScale().applyOptions({
           
              scaleMargins: {
                top: 0.1,
                bottom: 0,
              },
            });
          candleStickSeries.setData(data);
      
        const lineSeries = chart.addSeries(LightweightCharts.LineSeries);
        lineSeries.setData(data);

        const minMaxLineSeries = chart.addSeries(LightweightCharts.LineSeries);
        minMaxLineSeries.setData(formatForMinMaxLineData(data));

      const histogramSeries = chart.addSeries(LightweightCharts.HistogramSeries);

      histogramSeries.setData(formatForHistogramData(data));

      // chart.timeScale().scrollToPosition(0, true);
      chart.timeScale().fitContent();
        </script>
      </body>
    </html>